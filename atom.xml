<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Utopian-1.github.io</id>
    <title>Welcom to Utopia land </title>
    <updated>2020-10-10T11:16:39.120Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Utopian-1.github.io"/>
    <link rel="self" href="https://Utopian-1.github.io/atom.xml"/>
    <subtitle>Hello</subtitle>
    <logo>https://Utopian-1.github.io/images/avatar.png</logo>
    <icon>https://Utopian-1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Welcom to Utopia land </rights>
    <entry>
        <title type="html"><![CDATA[对称密码分析-维吉尼亚密码的破解]]></title>
        <id>https://Utopian-1.github.io/post/dui-cheng-mi-ma-fen-xi-wei-ji-ni-ya-mi-ma-de-po-jie/</id>
        <link href="https://Utopian-1.github.io/post/dui-cheng-mi-ma-fen-xi-wei-ji-ni-ya-mi-ma-de-po-jie/">
        </link>
        <updated>2020-10-10T11:10:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="维吉尼亚密码破解的python实现">维吉尼亚密码破解的Python实现</h1>
<h2 id="一破译结果">一.破译结果</h2>
<p><strong>第一组</strong></p>
<p>密文：<code>krkpekmcwxtvknugcmkxfwmgmjvpttuflihcumgxafsdajfupgzzmjlkyykxdvccyqiwdncebwhyjmgkazybtdfsitncwdnolqiacmchnhwcgxfzlwtxzlvgqecllhimbnudynagrttgiiycmvyyimjzqaxvkcgkgrawxupmjwqemiptzrtmqdciakjudnnuadfrimbbuvyaeqwshtpuyqhxvyaeffldmtvrjkpllsxtrlnvkiajfukycvgjgibubldppkfpmkkuplafslaqycaigushmqxcityrwukqdftkgrlstncudnnuzteqjrxyafshaqljsljfunhwiqtehncpkgxspkfvbstarlsgkxfibffldmerptrqlygxpfrwxtvbdgqkztmtfsqegumcfararhwerchvygczyzjaacgntgvfktmjvlpmkflpecjqtfdcclbncqwhycccbgeanyciclxncrwxofqieqmcshhdccughsxxvzdnhwtycmcbcrttvmurqlphxnwddkopqtehzapgpfrlkkkcpgadmgxdlrchvygczkerwxyfpawefsawukmefgkmpwqicnhwlnihvycsxckf</code></p>
<p>密钥：</p>
<p><code>crypt</code></p>
<p>明文：</p>
<p><code>iamaliveheremybelovedforthereasontoadoreyouohhowanxiousihavebeenforyouandhowsorryiamaboutallyoumusthavesufferedinhavingnonewsfromusmayheavengrantthatthisletterreachesyoudonotwritetomethiswouldcompromiseallofusandabovealldonotreturnunderanycircumstancesitisknownthatitwasyouwhohelpedustogetawayfromhereandallwouldbelostifyoushouldshowyourselfweareguardeddayandnightidonotcareyouarenotheredonotbetroubledonmyaccountnothingwillhappentomethenationalassemblewillshowleniencyfarewellthemostlovedofmenbequietifyoucantakecareofyourselfformyselficannotwriteanymorebutnothingintheworldcouldstopmetoadoreyouuptothedeath</code></p>
<p><strong>第二组</strong></p>
<p>密文：</p>
<p><code>cbkznkiyjsrofgnqadnzuqigscvxizgsjwucusrdkxuahgzrhywtvdjeiuwsrrtnpszbvpzncngztbvsrnzuqigscvfjwqgjwcytwdazuqigscvfjwqgjwjhkfdylmcbmhonbmbvdnvbmwbnacjaphhonbmbvdnvbmwbnaublsbdnjjneoroyfmxfhixpzpcozzuqigscvxcvhdmfgxmgovzsqmvzyvwyzmsczoajsejifoakdcrehwhgdehvmtnmvvmesvzifutzfjzoalwqztunwvdvmfhesvzifutzfjzoalwqztunpsnoyfleoxdetbwfsoyfjmfhjuxuagnarsfqydoyfjzsrzeujmfhjuubihrjdfinwsnepcawdnkbobvnmzucmghijjmbscjejnapddehlmqddmfxncqbfpxwfejifpqzhikiyaiozimubwuzufazsdjwdiudzmztivcmgp</code></p>
<p>密钥：</p>
<p><code>uiozvrb</code></p>
<p>明文：</p>
<p><code>itwasthebestoftimesitwastheworstoftimesitwastheageofwisdomitwastheageoffoolishnessitwastheepochofbeliefitwastheepochofincredulityitwastheseasonoflightitwastheseasonofdarknessitwasthespringofhopeitwasthewinterofdespairwehadeverythingbeforeuswehadnothingbeforeuswewereallgoingdirecttoheavenwewereallgoingdirecttheotherwayinshorttheperiodwassofarlikethepresentperiodthatsomeofitsnoisiestauthoritiesinsistedonitsbeingreceivedforgoodorforevilinthesuperlativedegreeofcomparisononly</code></p>
<h2 id="二破译原理">二.破译原理</h2>
<h3 id="1-确定密钥长度">1. 确定密钥长度</h3>
<blockquote>
<p>确定密钥长度有两种方法：<strong>Kasiski测试法</strong> 和 <strong>重合指数法(Coincidence Index)</strong> 在这里为方便代码实现，我们是用重合指数法实现。</p>
<p>设一门语言由n个字母构成，每个字母发生的概率为 <img src="https://www.zhihu.com/equation?tex=P_i" alt="[公式]" loading="lazy"> (1&lt;=i&lt;=n)，则重合指数是指其中两个随机元素相同的概率的和，记为 <img src="https://www.zhihu.com/equation?tex=CI%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7BP_%7Bi%7D%5E%7B2%7D%7D" alt="[公式]" loading="lazy"> 。</p>
<p>完全随机的英文文本 <img src="https://www.zhihu.com/equation?tex=CI%3D26%5Cleft%28+%5Cfrac%7B1%7D%7B26%7D+%5Cright%29%5E%7B2%7D%3D0.0385" alt="[公式]" loading="lazy"> ，一个有意义的英文文本 <img src="https://www.zhihu.com/equation?tex=CI%3D0.065" alt="[公式]" loading="lazy">。而对于给定密文的估计值 <img src="https://www.zhihu.com/equation?tex=CI%27" alt="[公式]" loading="lazy"> ， <img src="https://www.zhihu.com/equation?tex=L" alt="[公式]" loading="lazy"> 为密文的长度， <img src="https://www.zhihu.com/equation?tex=f_%7Bi%7D" alt="[公式]" loading="lazy"> 为26个字母中第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]" loading="lazy"> 个字母发生的次数</p>
<figure data-type="image" tabindex="1"><img src="https://www.zhihu.com/equation?tex=CI%27%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7B%5Cfrac%7Bf_i%7D%7BL%7D%C2%B7%5Cfrac%7Bf_i-1%7D%7BL-1%7D%7D" alt="[公式]" loading="lazy"></figure>
<p>则由 <img src="https://www.zhihu.com/equation?tex=CI%27" alt="[公式]" loading="lazy"> 就可以区分单表代换密码和多表代换密码。如果密文的重合指数较低，就可能是一个多表代换密码。因为单表代换改变的只是字母，并没有改变频率，故统计规律和自然语言相似。若结果接近 <img src="https://www.zhihu.com/equation?tex=0.065" alt="[公式]" loading="lazy"> ，则猜测正确。</p>
<p>因此用重合指数法进行测试，分别测试密钥长度m=2,3,4,5...10，即把密文分成m组，对每一组求出其CI值再求平均，就得出了每一种m所对应的平均CI值。再在所有分组情况中选出距离0.065最为接近的一种情况所对应的m，即确定了密钥长度。</p>
</blockquote>
<h3 id="2-确定密钥内容">2. 确定密钥内容</h3>
<blockquote>
<p>在这一步中，我们要使用拟重合指数法。</p>
<p>Chi测试</p>
<p>其中n代表某种语言由n个字母组成， <img src="https://www.zhihu.com/equation?tex=p_i" alt="[公式]" loading="lazy"> 表示字母i在维吉尼亚密文分布中发生的概率， <img src="https://www.zhihu.com/equation?tex=q_i" alt="[公式]" loading="lazy"> 表示字母i在正常英语文本分布中发生的概率，则拟重合指数可以定义为。</p>
<figure data-type="image" tabindex="2"><img src="https://www.zhihu.com/equation?tex=%5Cchi%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bp_iq_i%7D" alt="[公式]" loading="lazy"></figure>
<p>当两个频率分布类似时， <img src="https://www.zhihu.com/equation?tex=%5Cchi" alt="[公式]" loading="lazy"> 的值相对要高。</p>
<p><strong>对于一个移位密码：</strong></p>
<p>1、统计每个字母的频数P<sub>i</sub> = p<sub>0</sub>，p<sub>1</sub>，... p<sub>25</sub></p>
<p>2、获得通常文本的字母概率分布Q= q<sub>0</sub>，q<sub>1</sub>，... q<sub>25</sub></p>
<p>3、对分布 <img src="https://www.zhihu.com/equation?tex=P_i" alt="[公式]" loading="lazy"> 与Q计算相关卷积 <img src="https://www.zhihu.com/equation?tex=Correlation%28P_i%2CQ%29%3D%5Csum_%7Bj%3D0%7D%5E%7B26%7D%7BP_%7B%28i%2Bj%29mod26%7D%7D%5Ccdot%7Bq_j%7D" alt="[公式]" loading="lazy"> 。</p>
<p>4、得到最大相关值 <img src="https://www.zhihu.com/equation?tex=Correlation%28P_i%2CQ%29" alt="[公式]" loading="lazy"> 对应的i为位移量的估计值。</p>
</blockquote>
<h3 id="3-根据密钥恢复明文">3. 根据密钥恢复明文</h3>
<blockquote>
<p>直接调用Python的第三方库pychipher中的Vigenere 进行破译</p>
</blockquote>
<h2 id="三-源程序">三. 源程序</h2>
<p>​</p>
<pre><code>from pycipher import Vigenere


def count_each_char(string):  # 计算词频，返回一个列表
    C = [0] * 26
    for j in range(0, len(string)):
        for i in range(0, 26):
            if chr(i + ord('a')) == string[j]:
                C[i] = C[i] + 1
                break
    return C


def put_ci(c, cipherlen):  # 计算CI值
    k01 = 0
    for i in range(0, 26):
        k01 = c[i] * (c[i] - 1) + k01
    k02 = cipherlen * (cipherlen - 1)
    k = k01 / k02
    return k


def split(string, n):  # 对string分成n组
    length = len(string)
    re = []
    for i in range(0, n):
        temp = string[i:length:n]
        re.append(temp)
    return re


def correlation(P, Q):  # P为词频列表,返回P，Q的相关卷积
    corr = []
    for i in range(0, 26):
        result = 0
        for j in range(0, 26):
            index = (i + j) % 26
            result = result + P[index] * Q[j]
        corr.append(result)
    shift = corr.index(max(corr))
    return shift



ciphertext = 'krkpekmcwxtvknugcmkxfwmgmjvpttuflihcumgxafsdajfupgzzmjlkyykxdvccyqiwdncebwhyjmgkazybtdfsitncwdnolqiacmchnhwcgxfzlwtxzlvgqecllhimbnudynagrttgiiycmvyyimjzqaxvkcgkgrawxupmjwqemiptzrtmqdciakjudnnuadfrimbbuvyaeqwshtpuyqhxvyaeffldmtvrjkpllsxtrlnvkiajfukycvgjgibubldppkfpmkkuplafslaqycaigushmqxcityrwukqdftkgrlstncudnnuzteqjrxyafshaqljsljfunhwiqtehncpkgxspkfvbstarlsgkxfibffldmerptrqlygxpfrwxtvbdgqkztmtfsqegumcfararhwerchvygczyzjaacgntgvfktmjvlpmkflpecjqtfdcclbncqwhycccbgeanyciclxncrwxofqieqmcshhdccughsxxvzdnhwtycmcbcrttvmurqlphxnwddkopqtehzapgpfrlkkkcpgadmgxdlrchvygczkerwxyfpawefsawukmefgkmpwqicnhwlnihvycsxckf '
Q = [0.082, 0.015, 0.028, 0.043, 0.127, 0.022, 0.02, 0.061, 0.07, 0.002, 0.008, 0.04, 0.024, 0.067, 0.075, 0.019, 0.001, 0.06, 0.063, 0.091, 0.028, 0.01, 0.023, 0.001, 0.02, 0.001]

CI = []
for groups in range(2, 10):  # 假定密钥长度在2到10之间
    re = split(ciphertext, groups)
    sum_CI = 0
    for i in range(0, groups):
        sum_CI = sum_CI + put_ci(count_each_char(re[i]), len(re[i]))
    CI.append(abs((sum_CI / groups) - 0.065))

Best_group = 2 + CI.index(min(CI))  # 正确的分组
re = split(ciphertext, Best_group)
key_text = ''
for i in range(0, Best_group):
    # 对每一个分组进行破解
    group_freq = count_each_char(re[i])
    key = correlation(group_freq, Q)
    key_text = key_text + chr(key + ord('a'))

print(&quot;密钥为：&quot; + key_text)
print(&quot;解密后的明文为：&quot;)
print(Vigenere(key_text).decipher(ciphertext).lower())
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网安数基-LFSR]]></title>
        <id>https://Utopian-1.github.io/post/wang-an-shu-ji-lfsr/</id>
        <link href="https://Utopian-1.github.io/post/wang-an-shu-ji-lfsr/">
        </link>
        <updated>2020-09-27T08:22:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明文档-lfsr的实现与邻接矩阵推演">说明文档--LFSR的实现与邻接矩阵推演</h1>
<h2 id="lfsr的实现思路及原理">LFSR的实现思路及原理</h2>
<p>​	LFSR本质上是一个多位的01序列，在此为1051 bit，即1051位。经过抽头之后进行异或操作产生一个新位，并将新位添加到序列的最底部；同时，序列向右移位1个bit重复此过程便可实现线性反馈移位寄存器。</p>
<p>​	在数学原理中，可将线性反馈移位寄存器抽象为一个n维列向量q，而抽头可以抽象为一个n×n的矩阵A，则A*q=q'，q'即下一个状态的线性反馈移位寄存器。由此可以看出，物理上的移位操作可以通过LFSR与一个邻接矩阵相乘的操作进行实现。而且，LFSR的这个特性可以实现LSFR之后任意状态的预测。即若已知LSFR的初始状态和抽头规则（A与q已知），则q的x个状态之后的序列可以用A的x次方与q相乘得到。</p>
<h2 id="代码实现">代码实现</h2>
<p>​	为方便代码的实现，程序使用 bitset 进行实现。每32位分为一组，一共1051位，因此一共分为 len/32+1=33组，于是用bitset&lt;len/32+1&gt;表示。这样实际是表示了1056位，最后一组由于表示不满，以此最后一位的高5位为0。</p>
<p>​	下面进行bitset数组的初始化赋值。实现思路是使用bitset()本身的特性，可以将一个int型的数字变为二进制序列。但在具体实现的时候发现，由于每一组bitset是32位 ，int类型所表示的数字只能为-2147483648 ~ 2147483647，因此在这里将32位分割为8位一组，对每一个32位赋值4次，其中也包括赋值后的移位操作。最后一组bitset的处理方法需单独操作，但原理类似，在此不再赘述。循环完毕后就完成了对bitset[]的初始化操作。</p>
<p>​	下面进行LSFR的输出操作，由于32不是3的整数，加上移位的操作，使输出时要对当前位置进行判断，在输出到一组的最后的时候要尤其注意（因为涉及到组与组之间的连接与输出）。</p>
<p>​	最后实现LFSR的移位操作。对面每一组32位的bitset进行右移，同时用一个&quot;000000000000000000000000000001&quot;的bitset来与上一组bitset进行与运算，这样就取出了高一组的最低位数，再将这个数放到本组移位之后产生的最高位空缺中。循环往复，在处理最后一组时有所区别：没有了高一组bitset的最低位，而是调用CreateNew()子函数产生的新位进行填补。</p>
<h3 id="程序流程图">程序流程图：</h3>
<figure data-type="image" tabindex="1"><img src="https://Utopian-1.github.io/post-images/1601195177967.png" alt="" loading="lazy"></figure>
<h3 id="源代码部分">源代码部分</h3>
<p>子函数<code>CreatNew()</code>用于产生移位反馈的新位。</p>
<pre><code>string CreatNew(bitset&lt;32&gt; old[len/32+1])
{
    //定义抽头位置Tap
    bitset&lt;32&gt; Tap(&quot;00000000000000000000000000001100&quot;);
    bitset&lt;32&gt; temp=Tap;
    temp&amp;=old[0];
    bitset&lt;32&gt; New_one;
    string a;
    if (temp.count() == 1) //说明异或的结果为1
        a=&quot;00000100000000000000000000000000&quot;;
    else
        a=&quot;00000000000000000000000000000000&quot;;
    //cout&lt;&lt; &quot;子函数 返回的是：&quot;&lt;&lt; a &lt;&lt; endl;
    return a;
}
</code></pre>
<p>主函数</p>
<pre><code>int main() {
srand((unsigned int)time(0));//初始化种子为随机值
int clock =0;
int i,j;
bitset&lt;32&gt; bitset1[len/32+1];  //无参构造 默认每一位为０

//对初始的1051个元素进行初始化
for (i=0;i&lt;len/32;i++)
{
    for (j=0;j&lt;4;j++)
    {
        int rand_int=rand() %256;
        //对每一个32位的bitset1[]赋值一个0~255的数
        bitset&lt;32&gt; a(rand_int);
        a&lt;&lt;=8*j;
        bitset1[i]|=a;
    }
}
//对最后一组bitset进行初始化
int rand_int=rand()%2047;
bitset&lt;32&gt; a(rand_int);
bitset1[32]=a;
int rand_int2=rand()%2047;
bitset&lt;32&gt; b(rand_int2);
b&lt;&lt;=12;
bitset1[32]|=b;
rand_int=rand()%7;
bitset&lt;32&gt; c(rand_int);
c&lt;&lt;=24;
bitset1[32]|=c;
//最后一组bitset进行初始化完毕
// 初始化完毕，1051个元素已经赋好值,最高5位为0

//    输出初始的1051个状态
//    cout &lt;&lt; &quot;初始的1051个状态：&quot; &lt;&lt; endl;
//    for (i=0;i&lt;3;i++)
//    {
//        cout &lt;&lt; bitset1[i] &lt;&lt; endl;
//    }

i=0;
j=0;
for (clock = 0; clock &lt; 10; clock++) //输出10个clock的结果
{
    if (j&lt;=29)
    {
        cout &lt;&lt; bitset1[i][j]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i][j+1]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i][j+2]&lt;&lt; endl;
        j+=2;
    }
    else if (j==30)
    {
        cout &lt;&lt; bitset1[i][j]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i][j+1]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i+1][0]&lt;&lt; endl;
        j=0;
        i++;
    }
    else if (j==31)
    {
        cout &lt;&lt; bitset1[i][j]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i+1][0]&lt;&lt; endl;
        cout &lt;&lt; bitset1[i+1][1]&lt;&lt; endl;
        j=1;
        i++;
    }
    int k;
    //输入第一个状态的1051位序列和在最后新添加的数，返回下一个状态的
    for(k=0;k&lt;=len/32-1;k++)
    {
        bitset&lt;32&gt; left_low(1);
        left_low&amp;=bitset1[k+1];
        bitset1[k]&gt;&gt;=1;
        left_low&lt;&lt;=31;
        bitset1[k]|=left_low;
    }
    bitset1[k]&gt;&gt;=1;
    bitset1[k]|=bitset&lt;32&gt;(CreatNew(bitset1));
    cout &lt;&lt; &quot; &quot;&lt;&lt; endl;
}

//    int p; //输出经过移位反馈之后的1051个状态
//    cout &lt;&lt; &quot;经过移位反馈之后的1051个状态：&quot; &lt;&lt; endl;
//    for (p=0;p&lt;33;p++)
//    {
//        cout &lt;&lt; bitset1[p] &lt;&lt; endl;
//    }
return 0;
}
</code></pre>
<h2 id="输出截图">输出截图</h2>
<p>由于输出太长在此进行了部分输出结果的展示：</p>
<figure data-type="image" tabindex="2"><img src="https://Utopian-1.github.io/post-images/1601195159498.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一个帖子啦]]></title>
        <id>https://Utopian-1.github.io/post/hello-gridea/</id>
        <link href="https://Utopian-1.github.io/post/hello-gridea/">
        </link>
        <updated>2020-09-19T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="随便写点东西">随便写点东西</h1>
<h2 id="刚才写的不知道为啥找不到了">刚才写的不知道为啥找不到了</h2>
<p>emmmm<br>
那就再随便写一个吧</p>
]]></content>
    </entry>
</feed>