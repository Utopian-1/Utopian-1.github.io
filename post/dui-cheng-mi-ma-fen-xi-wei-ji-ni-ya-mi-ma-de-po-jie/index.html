<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>对称密码分析-维吉尼亚密码的破解 | Welcom to Utopia land </title>
<link rel="shortcut icon" href="https://Utopian-1.github.io/favicon.ico?v=1608126594485">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Utopian-1.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="对称密码分析-维吉尼亚密码的破解 | Welcom to Utopia land  - Atom Feed" href="https://Utopian-1.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="维吉尼亚密码破解的Python实现
一.破译结果
第一组
密文：krkpekmcwxtvknugcmkxfwmgmjvpttuflihcumgxafsdajfupgzzmjlkyykxdvccyqiwdncebwhyjmgkazybtdfs..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Utopian-1.github.io">
  <img class="avatar" src="https://Utopian-1.github.io/images/avatar.png?v=1608126594485" alt="">
  </a>
  <h1 class="site-title">
    Welcom to Utopia land 
  </h1>
  <p class="site-description">
    Hello
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              对称密码分析-维吉尼亚密码的破解
            </h2>
            <div class="post-info">
              <span>
                2020-10-10
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="维吉尼亚密码破解的python实现">维吉尼亚密码破解的Python实现</h1>
<h2 id="一破译结果">一.破译结果</h2>
<p><strong>第一组</strong></p>
<p>密文：<code>krkpekmcwxtvknugcmkxfwmgmjvpttuflihcumgxafsdajfupgzzmjlkyykxdvccyqiwdncebwhyjmgkazybtdfsitncwdnolqiacmchnhwcgxfzlwtxzlvgqecllhimbnudynagrttgiiycmvyyimjzqaxvkcgkgrawxupmjwqemiptzrtmqdciakjudnnuadfrimbbuvyaeqwshtpuyqhxvyaeffldmtvrjkpllsxtrlnvkiajfukycvgjgibubldppkfpmkkuplafslaqycaigushmqxcityrwukqdftkgrlstncudnnuzteqjrxyafshaqljsljfunhwiqtehncpkgxspkfvbstarlsgkxfibffldmerptrqlygxpfrwxtvbdgqkztmtfsqegumcfararhwerchvygczyzjaacgntgvfktmjvlpmkflpecjqtfdcclbncqwhycccbgeanyciclxncrwxofqieqmcshhdccughsxxvzdnhwtycmcbcrttvmurqlphxnwddkopqtehzapgpfrlkkkcpgadmgxdlrchvygczkerwxyfpawefsawukmefgkmpwqicnhwlnihvycsxckf</code></p>
<p>密钥：</p>
<p><code>crypt</code></p>
<p>明文：</p>
<p><code>iamaliveheremybelovedforthereasontoadoreyouohhowanxiousihavebeenforyouandhowsorryiamaboutallyoumusthavesufferedinhavingnonewsfromusmayheavengrantthatthisletterreachesyoudonotwritetomethiswouldcompromiseallofusandabovealldonotreturnunderanycircumstancesitisknownthatitwasyouwhohelpedustogetawayfromhereandallwouldbelostifyoushouldshowyourselfweareguardeddayandnightidonotcareyouarenotheredonotbetroubledonmyaccountnothingwillhappentomethenationalassemblewillshowleniencyfarewellthemostlovedofmenbequietifyoucantakecareofyourselfformyselficannotwriteanymorebutnothingintheworldcouldstopmetoadoreyouuptothedeath</code></p>
<p><strong>第二组</strong></p>
<p>密文：</p>
<p><code>cbkznkiyjsrofgnqadnzuqigscvxizgsjwucusrdkxuahgzrhywtvdjeiuwsrrtnpszbvpzncngztbvsrnzuqigscvfjwqgjwcytwdazuqigscvfjwqgjwjhkfdylmcbmhonbmbvdnvbmwbnacjaphhonbmbvdnvbmwbnaublsbdnjjneoroyfmxfhixpzpcozzuqigscvxcvhdmfgxmgovzsqmvzyvwyzmsczoajsejifoakdcrehwhgdehvmtnmvvmesvzifutzfjzoalwqztunwvdvmfhesvzifutzfjzoalwqztunpsnoyfleoxdetbwfsoyfjmfhjuxuagnarsfqydoyfjzsrzeujmfhjuubihrjdfinwsnepcawdnkbobvnmzucmghijjmbscjejnapddehlmqddmfxncqbfpxwfejifpqzhikiyaiozimubwuzufazsdjwdiudzmztivcmgp</code></p>
<p>密钥：</p>
<p><code>uiozvrb</code></p>
<p>明文：</p>
<p><code>itwasthebestoftimesitwastheworstoftimesitwastheageofwisdomitwastheageoffoolishnessitwastheepochofbeliefitwastheepochofincredulityitwastheseasonoflightitwastheseasonofdarknessitwasthespringofhopeitwasthewinterofdespairwehadeverythingbeforeuswehadnothingbeforeuswewereallgoingdirecttoheavenwewereallgoingdirecttheotherwayinshorttheperiodwassofarlikethepresentperiodthatsomeofitsnoisiestauthoritiesinsistedonitsbeingreceivedforgoodorforevilinthesuperlativedegreeofcomparisononly</code></p>
<h2 id="二破译原理">二.破译原理</h2>
<h3 id="1-确定密钥长度">1. 确定密钥长度</h3>
<blockquote>
<p>确定密钥长度有两种方法：<strong>Kasiski测试法</strong> 和 <strong>重合指数法(Coincidence Index)</strong> 在这里为方便代码实现，我们是用重合指数法实现。</p>
<p>设一门语言由n个字母构成，每个字母发生的概率为 <img src="https://www.zhihu.com/equation?tex=P_i" alt="[公式]" loading="lazy"> (1&lt;=i&lt;=n)，则重合指数是指其中两个随机元素相同的概率的和，记为 <img src="https://www.zhihu.com/equation?tex=CI%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7BP_%7Bi%7D%5E%7B2%7D%7D" alt="[公式]" loading="lazy"> 。</p>
<p>完全随机的英文文本 <img src="https://www.zhihu.com/equation?tex=CI%3D26%5Cleft%28+%5Cfrac%7B1%7D%7B26%7D+%5Cright%29%5E%7B2%7D%3D0.0385" alt="[公式]" loading="lazy"> ，一个有意义的英文文本 <img src="https://www.zhihu.com/equation?tex=CI%3D0.065" alt="[公式]" loading="lazy">。而对于给定密文的估计值 <img src="https://www.zhihu.com/equation?tex=CI%27" alt="[公式]" loading="lazy"> ， <img src="https://www.zhihu.com/equation?tex=L" alt="[公式]" loading="lazy"> 为密文的长度， <img src="https://www.zhihu.com/equation?tex=f_%7Bi%7D" alt="[公式]" loading="lazy"> 为26个字母中第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]" loading="lazy"> 个字母发生的次数</p>
<figure data-type="image" tabindex="1"><img src="https://www.zhihu.com/equation?tex=CI%27%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7B%5Cfrac%7Bf_i%7D%7BL%7D%C2%B7%5Cfrac%7Bf_i-1%7D%7BL-1%7D%7D" alt="[公式]" loading="lazy"></figure>
<p>则由 <img src="https://www.zhihu.com/equation?tex=CI%27" alt="[公式]" loading="lazy"> 就可以区分单表代换密码和多表代换密码。如果密文的重合指数较低，就可能是一个多表代换密码。因为单表代换改变的只是字母，并没有改变频率，故统计规律和自然语言相似。若结果接近 <img src="https://www.zhihu.com/equation?tex=0.065" alt="[公式]" loading="lazy"> ，则猜测正确。</p>
<p>因此用重合指数法进行测试，分别测试密钥长度m=2,3,4,5...10，即把密文分成m组，对每一组求出其CI值再求平均，就得出了每一种m所对应的平均CI值。再在所有分组情况中选出距离0.065最为接近的一种情况所对应的m，即确定了密钥长度。</p>
</blockquote>
<h3 id="2-确定密钥内容">2. 确定密钥内容</h3>
<blockquote>
<p>在这一步中，我们要使用拟重合指数法。</p>
<p>Chi测试</p>
<p>其中n代表某种语言由n个字母组成， <img src="https://www.zhihu.com/equation?tex=p_i" alt="[公式]" loading="lazy"> 表示字母i在维吉尼亚密文分布中发生的概率， <img src="https://www.zhihu.com/equation?tex=q_i" alt="[公式]" loading="lazy"> 表示字母i在正常英语文本分布中发生的概率，则拟重合指数可以定义为。</p>
<figure data-type="image" tabindex="2"><img src="https://www.zhihu.com/equation?tex=%5Cchi%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bp_iq_i%7D" alt="[公式]" loading="lazy"></figure>
<p>当两个频率分布类似时， <img src="https://www.zhihu.com/equation?tex=%5Cchi" alt="[公式]" loading="lazy"> 的值相对要高。</p>
<p><strong>对于一个移位密码：</strong></p>
<p>1、统计每个字母的频数P<sub>i</sub> = p<sub>0</sub>，p<sub>1</sub>，... p<sub>25</sub></p>
<p>2、获得通常文本的字母概率分布Q= q<sub>0</sub>，q<sub>1</sub>，... q<sub>25</sub></p>
<p>3、对分布 <img src="https://www.zhihu.com/equation?tex=P_i" alt="[公式]" loading="lazy"> 与Q计算相关卷积 <img src="https://www.zhihu.com/equation?tex=Correlation%28P_i%2CQ%29%3D%5Csum_%7Bj%3D0%7D%5E%7B26%7D%7BP_%7B%28i%2Bj%29mod26%7D%7D%5Ccdot%7Bq_j%7D" alt="[公式]" loading="lazy"> 。</p>
<p>4、得到最大相关值 <img src="https://www.zhihu.com/equation?tex=Correlation%28P_i%2CQ%29" alt="[公式]" loading="lazy"> 对应的i为位移量的估计值。</p>
</blockquote>
<h3 id="3-根据密钥恢复明文">3. 根据密钥恢复明文</h3>
<blockquote>
<p>直接调用Python的第三方库pychipher中的Vigenere 进行破译</p>
</blockquote>
<h2 id="三-源程序">三. 源程序</h2>
<p>​</p>
<pre><code>from pycipher import Vigenere


def count_each_char(string):  # 计算词频，返回一个列表
    C = [0] * 26
    for j in range(0, len(string)):
        for i in range(0, 26):
            if chr(i + ord('a')) == string[j]:
                C[i] = C[i] + 1
                break
    return C


def put_ci(c, cipherlen):  # 计算CI值
    k01 = 0
    for i in range(0, 26):
        k01 = c[i] * (c[i] - 1) + k01
    k02 = cipherlen * (cipherlen - 1)
    k = k01 / k02
    return k


def split(string, n):  # 对string分成n组
    length = len(string)
    re = []
    for i in range(0, n):
        temp = string[i:length:n]
        re.append(temp)
    return re


def correlation(P, Q):  # P为词频列表,返回P，Q的相关卷积
    corr = []
    for i in range(0, 26):
        result = 0
        for j in range(0, 26):
            index = (i + j) % 26
            result = result + P[index] * Q[j]
        corr.append(result)
    shift = corr.index(max(corr))
    return shift



ciphertext = 'krkpekmcwxtvknugcmkxfwmgmjvpttuflihcumgxafsdajfupgzzmjlkyykxdvccyqiwdncebwhyjmgkazybtdfsitncwdnolqiacmchnhwcgxfzlwtxzlvgqecllhimbnudynagrttgiiycmvyyimjzqaxvkcgkgrawxupmjwqemiptzrtmqdciakjudnnuadfrimbbuvyaeqwshtpuyqhxvyaeffldmtvrjkpllsxtrlnvkiajfukycvgjgibubldppkfpmkkuplafslaqycaigushmqxcityrwukqdftkgrlstncudnnuzteqjrxyafshaqljsljfunhwiqtehncpkgxspkfvbstarlsgkxfibffldmerptrqlygxpfrwxtvbdgqkztmtfsqegumcfararhwerchvygczyzjaacgntgvfktmjvlpmkflpecjqtfdcclbncqwhycccbgeanyciclxncrwxofqieqmcshhdccughsxxvzdnhwtycmcbcrttvmurqlphxnwddkopqtehzapgpfrlkkkcpgadmgxdlrchvygczkerwxyfpawefsawukmefgkmpwqicnhwlnihvycsxckf '
Q = [0.082, 0.015, 0.028, 0.043, 0.127, 0.022, 0.02, 0.061, 0.07, 0.002, 0.008, 0.04, 0.024, 0.067, 0.075, 0.019, 0.001, 0.06, 0.063, 0.091, 0.028, 0.01, 0.023, 0.001, 0.02, 0.001]

CI = []
for groups in range(2, 10):  # 假定密钥长度在2到10之间
    re = split(ciphertext, groups)
    sum_CI = 0
    for i in range(0, groups):
        sum_CI = sum_CI + put_ci(count_each_char(re[i]), len(re[i]))
    CI.append(abs((sum_CI / groups) - 0.065))

Best_group = 2 + CI.index(min(CI))  # 正确的分组
re = split(ciphertext, Best_group)
key_text = ''
for i in range(0, Best_group):
    # 对每一个分组进行破解
    group_freq = count_each_char(re[i])
    key = correlation(group_freq, Q)
    key_text = key_text + chr(key + ord('a'))

print(&quot;密钥为：&quot; + key_text)
print(&quot;解密后的明文为：&quot;)
print(Vigenere(key_text).decipher(ciphertext).lower())
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E7%9A%84python%E5%AE%9E%E7%8E%B0">维吉尼亚密码破解的Python实现</a>
<ul>
<li><a href="#%E4%B8%80%E7%A0%B4%E8%AF%91%E7%BB%93%E6%9E%9C">一.破译结果</a></li>
<li><a href="#%E4%BA%8C%E7%A0%B4%E8%AF%91%E5%8E%9F%E7%90%86">二.破译原理</a>
<ul>
<li><a href="#1-%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5%E9%95%BF%E5%BA%A6">1. 确定密钥长度</a></li>
<li><a href="#2-%E7%A1%AE%E5%AE%9A%E5%AF%86%E9%92%A5%E5%86%85%E5%AE%B9">2. 确定密钥内容</a></li>
<li><a href="#3-%E6%A0%B9%E6%8D%AE%E5%AF%86%E9%92%A5%E6%81%A2%E5%A4%8D%E6%98%8E%E6%96%87">3. 根据密钥恢复明文</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%BA%90%E7%A8%8B%E5%BA%8F">三. 源程序</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Utopian-1.github.io/post/wang-an-shu-ji-lfsr/">
              <h3 class="post-title">
                网安数基-LFSR
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://Utopian-1.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
